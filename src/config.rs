use std::{collections::BTreeMap, fs, net::SocketAddr, path::Path};

use anyhow::Context;
use serde::{Deserialize, Serialize};
use url::Url;

use crate::protocol::de_null_as_default;

fn default_logging_filter() -> String {
  "info".to_string()
}

fn default_thinking_enabled() -> bool {
  true
}

fn default_thinking_budget_tokens() -> u32 {
  10000
}

fn default_max_tokens() -> u32 {
  8192
}

fn default_timeout_seconds() -> u64 {
  120
}

fn default_history_summary_max_tokens() -> u32 {
  1024
}

fn default_history_summary_timeout_seconds() -> u64 {
  60
}

fn default_history_summary_trigger_on_history_size_chars() -> usize {
  800_000
}

fn default_history_summary_history_tail_size_chars_to_exclude() -> usize {
  250_000
}

fn default_history_summary_min_tail_exchanges() -> usize {
  2
}

fn default_history_summary_cache_ttl_ms() -> u64 {
  30 * 60 * 1000
}

fn default_history_summary_max_summarization_input_chars() -> usize {
  250_000
}

fn default_history_summary_prompt() -> String {
  r#"
You are performing a CONTEXT CHECKPOINT COMPACTION. Create a handoff summary for another LLM that will resume the task.

Include:
- Current progress and key decisions made
- Important context, constraints, or user preferences
- What remains to be done (clear next steps)
- Any critical data, examples, or references needed to continue

Be concise, structured, and focused on helping the next LLM seamlessly continue the work.
"#
    .trim()
    .to_string()
}

fn default_history_summary_trigger_strategy() -> String {
  "auto".to_string()
}

fn default_history_summary_trigger_on_context_ratio() -> f32 {
  0.70
}

fn default_history_summary_target_context_ratio() -> f32 {
  0.55
}

fn default_history_summary_template() -> String {
  r#"
<supervisor>
Conversation history between Agent(you) and the user and history of tool calls was abridged and summarized to reduce context size.
Abridged conversation history:
{abridged_history}

Summary was generated by Agent(you) so 'I' in the summary represents Agent(you).
Here is the summary:
{summary}

Continue the conversation and finish the task given by the user from this point.
</supervisor>"#
    .trim()
    .to_string()
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Config {
  pub server: ServerConfig,
  pub proxy: ProxyConfig,
  pub official: OfficialConfig,
  pub byok: ByokConfig,
  #[serde(default)]
  pub history_summary: HistorySummaryConfig,
  #[serde(default)]
  pub logging: LoggingConfig,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct ServerConfig {
  pub host: String,
  pub port: u16,
}

impl ServerConfig {
  pub fn socket_addr(&self) -> anyhow::Result<SocketAddr> {
    let addr: SocketAddr = format!("{}:{}", self.host, self.port)
      .parse()
      .context("server.host/server.port 不是合法 socket 地址")?;
    Ok(addr)
  }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct ProxyConfig {
  pub auth_token: String,
}

impl ProxyConfig {
  pub fn validate(&self) -> anyhow::Result<()> {
    if self.auth_token.trim().is_empty() {
      anyhow::bail!("proxy.auth_token 不能为空");
    }
    Ok(())
  }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct OfficialConfig {
  pub base_url: String,
  pub api_token: String,
}

impl OfficialConfig {
  pub fn validate(&self) -> anyhow::Result<()> {
    if self.base_url.trim().is_empty() {
      anyhow::bail!("official.base_url 不能为空");
    }
    if self.api_token.trim().is_empty() {
      anyhow::bail!("official.api_token 不能为空");
    }
    let _ = Url::parse(&self.base_url).context("official.base_url 不是合法 URL")?;
    Ok(())
  }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct ByokConfig {
  pub providers: Vec<ProviderConfig>,
  #[serde(default)]
  pub active_provider_id: Option<String>,
}

impl ByokConfig {
  pub fn validate(&self) -> anyhow::Result<()> {
    if self.providers.is_empty() {
      anyhow::bail!("byok.providers 不能为空");
    }

    let mut seen_ids: std::collections::HashSet<String> = std::collections::HashSet::new();
    for p in &self.providers {
      p.validate()?;
      let id = p.id().trim();
      if id.is_empty() {
        anyhow::bail!("byok.providers[].id 不能为空");
      }
      if id.contains(':') {
        anyhow::bail!(
          "byok.providers[].id 不能包含 ':'（会破坏 byok:<providerId>:<modelId> 解析）：{id}"
        );
      }
      if !seen_ids.insert(id.to_string()) {
        anyhow::bail!("byok.providers[].id 重复：{id}");
      }
    }
    if let Some(id) = &self.active_provider_id {
      let id = id.trim();
      if id.is_empty() {
        anyhow::bail!("byok.active_provider_id 不能为空字符串（或删除该字段）");
      }
      if !self.providers.iter().any(|p| p.id().trim() == id) {
        anyhow::bail!("byok.active_provider_id 未命中 providers: {id}");
      }
    }
    Ok(())
  }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
#[serde(tag = "type")]
pub enum ProviderConfig {
  #[serde(rename = "anthropic")]
  Anthropic(AnthropicProviderConfig),
  #[serde(
    rename = "openai_compatible",
    alias = "openai-compatible",
    alias = "openai"
  )]
  OpenAICompatible(OpenAICompatibleProviderConfig),
}

impl ProviderConfig {
  pub fn id(&self) -> &str {
    match self {
      ProviderConfig::Anthropic(p) => p.id.as_str(),
      ProviderConfig::OpenAICompatible(p) => p.id.as_str(),
    }
  }

  pub fn validate(&self) -> anyhow::Result<()> {
    match self {
      ProviderConfig::Anthropic(p) => p.validate(),
      ProviderConfig::OpenAICompatible(p) => p.validate(),
    }
  }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct AnthropicProviderConfig {
  pub id: String,
  pub base_url: String,
  pub api_key: String,
  pub default_model: String,
  #[serde(default = "default_max_tokens")]
  pub max_tokens: u32,
  #[serde(default = "default_timeout_seconds")]
  pub timeout_seconds: u64,
  #[serde(default)]
  pub thinking: ThinkingConfig,
  #[serde(default)]
  pub extra_headers: BTreeMap<String, String>,
}

impl AnthropicProviderConfig {
  pub fn validate(&self) -> anyhow::Result<()> {
    if self.id.trim().is_empty() {
      anyhow::bail!("byok.providers[type=anthropic].id 不能为空");
    }
    if self.base_url.trim().is_empty() {
      anyhow::bail!("byok.providers[type=anthropic].base_url 不能为空");
    }
    if self.api_key.trim().is_empty() {
      anyhow::bail!("byok.providers[type=anthropic].api_key 不能为空");
    }
    if self.default_model.trim().is_empty() {
      anyhow::bail!("byok.providers[type=anthropic].default_model 不能为空");
    }
    let _ =
      Url::parse(&self.base_url).context("byok.providers[type=anthropic].base_url 不是合法 URL")?;
    Ok(())
  }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct OpenAICompatibleProviderConfig {
  pub id: String,
  pub base_url: String,
  pub api_key: String,
  pub default_model: String,
  #[serde(default = "default_max_tokens")]
  pub max_tokens: u32,
  #[serde(default = "default_timeout_seconds")]
  pub timeout_seconds: u64,
  #[serde(default)]
  pub extra_headers: BTreeMap<String, String>,
}

impl OpenAICompatibleProviderConfig {
  pub fn validate(&self) -> anyhow::Result<()> {
    if self.id.trim().is_empty() {
      anyhow::bail!("byok.providers[type=openai_compatible].id 不能为空");
    }
    if self.base_url.trim().is_empty() {
      anyhow::bail!("byok.providers[type=openai_compatible].base_url 不能为空");
    }
    if self.api_key.trim().is_empty() {
      anyhow::bail!("byok.providers[type=openai_compatible].api_key 不能为空");
    }
    if self.default_model.trim().is_empty() {
      anyhow::bail!("byok.providers[type=openai_compatible].default_model 不能为空");
    }
    let _ = Url::parse(&self.base_url)
      .context("byok.providers[type=openai_compatible].base_url 不是合法 URL")?;
    Ok(())
  }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct ThinkingConfig {
  #[serde(default = "default_thinking_enabled")]
  pub enabled: bool,
  #[serde(default = "default_thinking_budget_tokens")]
  pub budget_tokens: u32,
}

impl Default for ThinkingConfig {
  fn default() -> Self {
    Self {
      enabled: default_thinking_enabled(),
      budget_tokens: default_thinking_budget_tokens(),
    }
  }
}

impl Config {
  pub fn load(path: &Path) -> anyhow::Result<Self> {
    let bytes = fs::read(path).with_context(|| format!("读取配置失败: {}", path.display()))?;
    let mut config: Self =
      serde_yaml::from_slice(&bytes).context("解析 YAML 配置失败 (config.yaml)")?;
    config.apply_defaults();
    config.validate()?;
    Ok(config)
  }

  pub fn save(&self, path: &Path) -> anyhow::Result<()> {
    let mut next = self.clone();
    next.apply_defaults();
    next.validate()?;
    let yaml = serde_yaml::to_string(&next).context("序列化 YAML 配置失败")?;
    fs::write(path, yaml).with_context(|| format!("写入配置失败: {}", path.display()))?;
    Ok(())
  }

  pub fn apply_defaults(&mut self) {
    self.history_summary.apply_defaults(&self.byok);
  }

  pub fn validate(&self) -> anyhow::Result<()> {
    if self.server.host.trim().is_empty() {
      anyhow::bail!("server.host 不能为空");
    }
    if self.server.port == 0 {
      anyhow::bail!("server.port 不能为 0");
    }
    self.proxy.validate()?;
    self.official.validate()?;
    self.byok.validate()?;
    self.history_summary.validate(&self.byok)?;
    self.logging.validate()?;
    Ok(())
  }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct HistorySummaryConfig {
  #[serde(default)]
  pub enabled: bool,
  #[serde(default)]
  pub client_compaction_enabled: bool,
  #[serde(default, deserialize_with = "de_null_as_default")]
  pub provider_id: String,
  #[serde(default, deserialize_with = "de_null_as_default")]
  pub model: String,
  #[serde(default = "default_history_summary_max_tokens")]
  pub max_tokens: u32,
  #[serde(default = "default_history_summary_timeout_seconds")]
  pub timeout_seconds: u64,
  #[serde(default = "default_history_summary_trigger_on_history_size_chars")]
  pub trigger_on_history_size_chars: usize,
  #[serde(default = "default_history_summary_trigger_strategy")]
  pub trigger_strategy: String,
  #[serde(default = "default_history_summary_trigger_on_context_ratio")]
  pub trigger_on_context_ratio: f32,
  #[serde(default = "default_history_summary_target_context_ratio")]
  pub target_context_ratio: f32,
  #[serde(default)]
  pub context_window_tokens_default: u32,
  #[serde(default)]
  pub context_window_tokens_overrides: BTreeMap<String, u32>,
  #[serde(default = "default_history_summary_history_tail_size_chars_to_exclude")]
  pub history_tail_size_chars_to_exclude: usize,
  #[serde(default = "default_history_summary_min_tail_exchanges")]
  pub min_tail_exchanges: usize,
  #[serde(default = "default_history_summary_cache_ttl_ms")]
  pub cache_ttl_ms: u64,
  #[serde(default = "default_history_summary_max_summarization_input_chars")]
  pub max_summarization_input_chars: usize,
  #[serde(default = "default_history_summary_prompt")]
  pub prompt: String,
  #[serde(default)]
  pub rolling_summary: bool,
  #[serde(default = "default_history_summary_template")]
  pub summary_node_request_message_template: String,
  #[serde(default)]
  pub abridged_history_params: AbridgedHistoryParams,
}

impl Default for HistorySummaryConfig {
  fn default() -> Self {
    Self {
      enabled: false,
      client_compaction_enabled: false,
      provider_id: String::new(),
      model: String::new(),
      max_tokens: default_history_summary_max_tokens(),
      timeout_seconds: default_history_summary_timeout_seconds(),
      trigger_on_history_size_chars: default_history_summary_trigger_on_history_size_chars(),
      trigger_strategy: default_history_summary_trigger_strategy(),
      trigger_on_context_ratio: default_history_summary_trigger_on_context_ratio(),
      target_context_ratio: default_history_summary_target_context_ratio(),
      context_window_tokens_default: 0,
      context_window_tokens_overrides: BTreeMap::new(),
      history_tail_size_chars_to_exclude: default_history_summary_history_tail_size_chars_to_exclude(
      ),
      min_tail_exchanges: default_history_summary_min_tail_exchanges(),
      cache_ttl_ms: default_history_summary_cache_ttl_ms(),
      max_summarization_input_chars: default_history_summary_max_summarization_input_chars(),
      prompt: default_history_summary_prompt(),
      rolling_summary: true,
      summary_node_request_message_template: default_history_summary_template(),
      abridged_history_params: AbridgedHistoryParams::default(),
    }
  }
}

impl HistorySummaryConfig {
  pub fn apply_defaults(&mut self, byok: &ByokConfig) {
    if !self.enabled {
      return;
    }

    if self.provider_id.trim().is_empty() {
      if let Some(id) = byok
        .active_provider_id
        .as_deref()
        .map(str::trim)
        .filter(|s| !s.is_empty())
      {
        self.provider_id = id.to_string();
      } else if let Some(first) = byok.providers.first() {
        let id = first.id().trim();
        if !id.is_empty() {
          self.provider_id = id.to_string();
        }
      }
    }

    if self.model.trim().is_empty() {
      let pid = self.provider_id.trim();
      if let Some(p) = byok.providers.iter().find(|p| p.id().trim() == pid) {
        let default_model = match p {
          ProviderConfig::Anthropic(p) => p.default_model.as_str(),
          ProviderConfig::OpenAICompatible(p) => p.default_model.as_str(),
        };
        if !default_model.trim().is_empty() {
          self.model = default_model.trim().to_string();
        }
      }
    }
  }

  pub fn validate(&self, byok: &ByokConfig) -> anyhow::Result<()> {
    if !self.enabled {
      return Ok(());
    }
    if self.provider_id.trim().is_empty() {
      anyhow::bail!("history_summary.provider_id 不能为空（用于专用摘要模型）");
    }
    if !byok
      .providers
      .iter()
      .any(|p| p.id().trim() == self.provider_id.trim())
    {
      anyhow::bail!(
        "history_summary.provider_id 未命中 byok.providers[].id: {}",
        self.provider_id.trim()
      );
    }
    if self.model.trim().is_empty() {
      anyhow::bail!("history_summary.model 不能为空（用于专用摘要模型）");
    }
    if self.prompt.trim().is_empty() {
      anyhow::bail!("history_summary.prompt 不能为空（用于生成 summary_text；可使用默认 Codex 风格 prompt）");
    }
    if self.trigger_on_history_size_chars == 0 {
      anyhow::bail!("history_summary.trigger_on_history_size_chars 不能为 0（否则永远不会触发）");
    }
    let strategy = self.trigger_strategy.trim().to_ascii_lowercase();
    if strategy != "auto" && strategy != "chars" && strategy != "ratio" {
      anyhow::bail!("history_summary.trigger_strategy 仅支持 auto/chars/ratio");
    }
    if !(0.0..=1.0).contains(&self.trigger_on_context_ratio) || self.trigger_on_context_ratio <= 0.0 {
      anyhow::bail!("history_summary.trigger_on_context_ratio 取值范围为 (0,1]");
    }
    if !(0.0..=1.0).contains(&self.target_context_ratio) || self.target_context_ratio <= 0.0 {
      anyhow::bail!("history_summary.target_context_ratio 取值范围为 (0,1]");
    }
    if self.target_context_ratio > self.trigger_on_context_ratio {
      anyhow::bail!("history_summary.target_context_ratio 不能大于 trigger_on_context_ratio（否则无法收敛）");
    }
    if self.min_tail_exchanges == 0 {
      anyhow::bail!("history_summary.min_tail_exchanges 不能为 0");
    }
    if self.summary_node_request_message_template.trim().is_empty() {
      anyhow::bail!("history_summary.summary_node_request_message_template 不能为空");
    }
    self.abridged_history_params.validate()?;
    Ok(())
  }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct AbridgedHistoryParams {
  #[serde(default = "default_abridged_total_chars_limit")]
  pub total_chars_limit: usize,
  #[serde(default = "default_abridged_user_message_chars_limit")]
  pub user_message_chars_limit: usize,
  #[serde(default = "default_abridged_agent_response_chars_limit")]
  pub agent_response_chars_limit: usize,
  #[serde(default = "default_abridged_action_chars_limit")]
  pub action_chars_limit: usize,
  #[serde(default = "default_abridged_num_files_modified_limit")]
  pub num_files_modified_limit: usize,
  #[serde(default = "default_abridged_num_files_created_limit")]
  pub num_files_created_limit: usize,
  #[serde(default = "default_abridged_num_files_deleted_limit")]
  pub num_files_deleted_limit: usize,
  #[serde(default = "default_abridged_num_files_viewed_limit")]
  pub num_files_viewed_limit: usize,
  #[serde(default = "default_abridged_num_terminal_commands_limit")]
  pub num_terminal_commands_limit: usize,
}

fn default_abridged_total_chars_limit() -> usize {
  10_000
}

fn default_abridged_user_message_chars_limit() -> usize {
  1_000
}

fn default_abridged_agent_response_chars_limit() -> usize {
  2_000
}

fn default_abridged_action_chars_limit() -> usize {
  200
}

fn default_abridged_num_files_modified_limit() -> usize {
  10
}

fn default_abridged_num_files_created_limit() -> usize {
  10
}

fn default_abridged_num_files_deleted_limit() -> usize {
  10
}

fn default_abridged_num_files_viewed_limit() -> usize {
  10
}

fn default_abridged_num_terminal_commands_limit() -> usize {
  10
}

impl Default for AbridgedHistoryParams {
  fn default() -> Self {
    Self {
      total_chars_limit: default_abridged_total_chars_limit(),
      user_message_chars_limit: default_abridged_user_message_chars_limit(),
      agent_response_chars_limit: default_abridged_agent_response_chars_limit(),
      action_chars_limit: default_abridged_action_chars_limit(),
      num_files_modified_limit: default_abridged_num_files_modified_limit(),
      num_files_created_limit: default_abridged_num_files_created_limit(),
      num_files_deleted_limit: default_abridged_num_files_deleted_limit(),
      num_files_viewed_limit: default_abridged_num_files_viewed_limit(),
      num_terminal_commands_limit: default_abridged_num_terminal_commands_limit(),
    }
  }
}

impl AbridgedHistoryParams {
  pub fn validate(&self) -> anyhow::Result<()> {
    if self.total_chars_limit == 0 {
      anyhow::bail!("history_summary.abridged_history_params.total_chars_limit 不能为 0");
    }
    Ok(())
  }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct LoggingConfig {
  #[serde(default = "default_logging_filter")]
  pub filter: String,
  #[serde(default)]
  pub dump_chat_stream_body: bool,
}

impl Default for LoggingConfig {
  fn default() -> Self {
    Self {
      filter: default_logging_filter(),
      dump_chat_stream_body: false,
    }
  }
}

impl LoggingConfig {
  pub fn validate(&self) -> anyhow::Result<()> {
    if self.filter.trim().is_empty() {
      anyhow::bail!("logging.filter 不能为空");
    }
    tracing_subscriber::EnvFilter::try_new(self.filter.trim())
      .context("logging.filter 不是合法 tracing filter (EnvFilter 语法)")?;
    Ok(())
  }
}

pub fn init_tracing(logging: &LoggingConfig) -> anyhow::Result<()> {
  let filter = tracing_subscriber::EnvFilter::try_new(logging.filter.trim())
    .context("logging.filter 不是合法 tracing filter (EnvFilter 语法)")?;
  tracing_subscriber::fmt()
    .with_env_filter(filter)
    .with_target(false)
    .compact()
    .init();
  Ok(())
}
